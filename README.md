# SPP-UCP - A CCSDS Space Packet Protocol Implementation with an UDP-based Communication Provider

12/13/2024

## Introduction

This repository contains the source code for the SPP-UCP project, which is a CCSDS Space Packet Protocol (SPP) implementation as an Underlying Communication Provider (UCP) designed to run under Bundle Protocol v7 to test the SPP CLA implementation according to Annex B of the CCSDS Bundle Protocol Version 7 Orange Book.

The SPP CLA specification recommends that the Octet_String service for SPP be used:

```text
OCTET_STRING.request (Octet String, APID, Secondary Header Indicator, Packet Type, Packet Sequence Count/Packet Name) 

OCTET_STRING.indication (Octet String, APID, Secondary Header Indicator, Data Loss Indicator (optional))
```

The bundle size should be no more than 65,536 bytes, and the following shall apply:

- One CBOR-encoded Bundle per Space Packet - generated by CLA
- APID depends on the link destination - provided by CLA, as determined by the CLA's peer identity
- No secondary packet header - always set to false (or 0)
- Only use packet sequence counter - provided by CLA, which will increment from 0 and go up indefinitely
- Loss indicator - provided by SPP when noticing a gap in sequence number.

## SPP CLA Prototype Design for ION

Unlike TCPCLA and UDPCLA, which have well-known APIs for packaging data into TCP stream and UDP datagrams, there are no standard APIs for invoking SPP service. Those API would be implementation specific.

Therefore, in order to build a SPP CLA, we need to build a simple SPP provider; otherwise there is nothing for the SPP CLA to interact with. In reality, the SPP provider should be externally implemented and then integrated into ION.

With that in mind, we design the SPP CLA prototype in ION with the following in mind:

1. The simple SPP provider should be portable for testing over a wide range of testing environment. 
2. The simple SPP provider should offers API matching the service primitive of SPP implementation conforming to CCSDS Bluebook.
3. We want to make sure the prototype CLA is interfaced with the simple SPP provider in such as way that it is fairly straight forward to _swap_ it out.
4. We want to avoid baking in any particular Interprocess Communication between the CLA and an externally sourced SPP provider software. The simple SPP provider will be available through a small set of library functions that performs only the formatting and parsing of SPP. We rely on the SPP CLA to provide a UDP-based delivery mechanism between two DTN nodes.
   - Should a future SPP provider have an interface with the lower layer (e.g., CCSDS frames or spacecraft/ground station comm systems), then the UDP-delivery mechanism in the CLA can be either removed, disable, or bypassed.

![SPP CLA Prototype in ION](./spp-cla-prototype.png)

## Install Dependencies

The Space Packet Protocol provider library is based on the `spacepackets` [python package](https://pypi.org/project/spacepackets/), which requires python version >= 3.9. Check the version:

```bash
python --version
```

If you don't want to upgrade to higher python version, please install and enable a higher version (but not as default.) Example in RHEL:

```bash
sudo dnf module enable python39
sudo dnf install python39
```

This will install Python 3.9 as /usr/bin/python3.9 without affecting the default /usr/bin/python3 (Python 3.6).

Check python version again. Sometimes this may upgrade to a different version. In the RHEL8 example, the python version was actually upgraded to 3.11.

It might be a good idea to set up python virtual environment using required python version. For example, if the only python version on the host higher than 3.9 is 3.11, then use it to create the python environment, which will make it the default version in that environment.

```bash
python3.11 -m venv spp-ucp-env
```

Activate virtual environment:

```bash
source ./spp-ucp-env/bin/activate
```

To build actual CCSDS Space Packets, we use the `spacepackets` python package. See [documentation.](https://spacepackets.readthedocs.io/en/latest/examples.html)

Install the `spacepackets` package using pip: 

```
python -m pip install spacepackets
```

## Example of using the `spacepackets` package

The `send_space_packet_udp.py` script will construct a spacepacket and send it via UDP. The `recv_space_packet_udp.py` script will receive a packet over UDP, parse it, and display its content.

Start the receive script:

```bash
python recv_space_packet_udp.py 127.0.0.1 5000
```

Send a spacepacket:

```bash
python send_space_packet_udp.py --apid 250 --seq_count 1 --payload "01020304" 127.0.0.1 5000
```

## Build the `space_packet_sender.c` Program

Install the `space_packet_module`.

``` bash
cd ./space_packet_module
python -m pip install .
```

Confirm it is installed from any directory (other than where the modules is stored.)

```bash
# Go to a different directory and run:
python -c "import space_packet_module; print('Module found')"
```

Install the Python C development package in order to  build the C wrapper functions for python:

This must be install on the host so you need to specify the exact version. So you need to specify python3.11-dev instead of just python3-dev.

Again, from inside the virtual environment where the module is installed, run `python --version' to confirm the actual version of python in the virtual environment. For example it is 3.11. Then install the development package specific to that version:

For Ubuntu
```bash
sudo apt-get install python3.11-dev
```

For RHEL8:
```bash
sudo subscription-manager repos --enable codeready-builder-for-rhel-8-$(arch)-rpms
sudo dnf module enable python:3.11
sudo dnf install python3.11 python3.11-devel
```

Verify installation of the development header:

```bash
ls /usr/include/python3.11/Python.h
```
ls /usr

Confirm Python include path:

```bash
python3.11-config --includes
python3.11-config --ldflags
```

Take note if the `-lpython3.11` is part of the include flag output. If not, make sure the shared library is avilable:

```bash
find /usr -name "libpython3.11.so"
```

If it is available, then you just have to manually add the flag to the compiler.

## Build the `space_packet_sender.c` Program

```bash
# Compile command that manually adds -lpython3.11 at the end
gcc -g -o space_packet_sender space_packet_sender.c $(python3.11-config --includes) $(python3.11-config --ldflags) $(python3.11-config --libs) -lpython3.11
```

# Using the CMake build system

## Build the Project

```bash
mkdir build && cd build
cmake ..
make
```
## Run the Test

```bash
ctest --output-on-failure
```



